#include "hal_data.h"
#include "RTT/SEGGER_RTT.h"

#define DATA_FLASH_BLOCK_0              0x08000000U       /* 64 B */
#define DATA_FLASH_BLOCK_COUNT          128
#define DATA_FLASH_BLOCK_SIZE           64

#define  BUF_SIZE   64

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

fsp_err_t data_flash_operation(void);
void flash_bgo_callback(flash_callback_args_t *p_args);
static fsp_err_t blankcheck_event_flag(void);

static volatile bool flash_not_blank        = false;
static volatile bool flash_blank            = false;
static volatile bool flash_write_complete   = false;
static volatile bool flash_erase_complete   = false;

fsp_err_t data_flash_operation(void)
{
    uint8_t write_buf[BUF_SIZE] = {0};
    uint8_t read_buf[BUF_SIZE]= {0};
    fsp_err_t err = FSP_SUCCESS;
    flash_result_t blank_check_result = FLASH_RESULT_BLANK;

    /* Open Flash_HP */
    err = R_FLASH_HP_Open(&g_flash0_ctrl, &g_flash0_cfg);
    if(FSP_SUCCESS != err)
    {
        return err;
    }

    for(uint8_t i=0; i<BUF_SIZE; i++)
    {
        write_buf[i] = i;
    }

    /* Erase Block */
    err = R_FLASH_HP_Erase(&g_flash0_ctrl, DATA_FLASH_BLOCK_0, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* Wait for the erase complete */
    if(true == g_flash0_cfg.data_flash_bgo)
    {
        while(!flash_erase_complete);
        flash_erase_complete = false;
    }

    /* Data flash blank check */
    err = R_FLASH_HP_BlankCheck(&g_flash0_ctrl, DATA_FLASH_BLOCK_0, DATA_FLASH_BLOCK_SIZE, &blank_check_result);
    if (FSP_SUCCESS != err)
    {
        return err;
    }
    /* Validate the blank check result */
    switch(blank_check_result)
    {
        case FLASH_RESULT_BLANK:
            break;
        case FLASH_RESULT_NOT_BLANK:
            return (fsp_err_t)FLASH_RESULT_NOT_BLANK;
        case FLASH_RESULT_BGO_ACTIVE:
            /* BlankCheck will update in Callback */
            /* Event flag will be updated in the blank check function when BGO is enabled */
            err = blankcheck_event_flag();
            if(FSP_SUCCESS != err)
            {
                return err;
            }
            break;
    }

    /* Write code flash data*/
    err = R_FLASH_HP_Write(&g_flash0_ctrl, (uint32_t)write_buf, DATA_FLASH_BLOCK_0, BUF_SIZE);
    /* Error Handle */
    if (FSP_SUCCESS != err)
    {
        return err;
    }
    /* Wait for the write complete event flag, if BGO is SET  */
    if (true == g_flash0_cfg.data_flash_bgo)
    {
        while (!flash_write_complete);
        flash_write_complete = false;
    }

    /*Read code flash data */
    memcpy(read_buf, (uint8_t *)DATA_FLASH_BLOCK_0, BUF_SIZE);

    /* comparing the write_buffer and read_buffer */
    if (0 == memcmp(read_buf, write_buf, BUF_SIZE))
    {
        SEGGER_RTT_printf(0, "R/W buffer is successful\r\n");
    }
    else
    {
        SEGGER_RTT_printf(0, "R/W buffer is fail\r\n");
        return FSP_ERR_WRITE_FAILED;
    }

    /* close Flash_HP */
    err = R_FLASH_HP_Close(&g_flash0_ctrl);
    if(FSP_SUCCESS != err)
    {
        return err;
    }

    return err;
}

static fsp_err_t blankcheck_event_flag(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Wait for callback function to set flag */
    while (!(flash_not_blank || flash_blank));

    if (flash_not_blank)
    {
        /* Reset Flag */
        flash_not_blank = false;
        return (fsp_err_t)FLASH_EVENT_NOT_BLANK;
    }
    else
    {
        /* Reset Flag */
        flash_blank = false;
    }

    return err;
}

void flash_bgo_callback(flash_callback_args_t *p_args)
{
    switch(p_args->event)
    {
        case FLASH_EVENT_NOT_BLANK:
            flash_not_blank = true;
            break;
        case FLASH_EVENT_BLANK:
            flash_blank = true;
            break;
        case FLASH_EVENT_ERASE_COMPLETE:
            flash_erase_complete = true;
            break;
        case FLASH_EVENT_WRITE_COMPLETE:
            flash_write_complete = true;
            break;
        default:
            break;
    }
}

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    SEGGER_RTT_printf(0, "Start Application\r\n");

    data_flash_operation();

    while(1)
    {
        R_IOPORT_PinWrite(&g_ioport_ctrl, LED1, BSP_IO_LEVEL_HIGH);
        R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
        R_IOPORT_PinWrite(&g_ioport_ctrl, LED1, BSP_IO_LEVEL_LOW);
        R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
